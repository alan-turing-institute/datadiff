% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch.R
\name{compose_patch}
\alias{compose_patch}
\title{Compose patches}
\usage{
compose_patch(...)
}
\arguments{
\item{...}{n patches (possibly themselves composed) to apply in order from right to left.}
}
\value{
A composite patch object.
}
\description{
Construct multiple patches. The advantage of using this function,
rather than calling \code{purrr::compose} directly, is that the class of the
return value is \code{patch}, which helps when printing. However both methods
will produce objects for which \code{is_patch} returns \code{TRUE}.
}
\examples{
# Patches are applied from right to left (as in mathematical function
# composition) and are printed in order of application:
compose_patch(patch_permute(8:1), patch_shift(2L, shift = 10))

# Use do.call if the components are in a list.
patch_list <- list(patch_permute(8:1), patch_shift(2L, shift = 10))
do.call(compose_patch, args = patch_list)
}
\seealso{
\code{\link{decompose_patch}} \code{\link{compose}}
}
