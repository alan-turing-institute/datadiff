% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ddiff.R
\name{ddiff}
\alias{ddiff}
\title{Diff two data frames}
\usage{
ddiff(df1, df2, mismatch = diffness,
  patch_generators = list(gen_patch_rescale, gen_patch_recode),
  patch_penalties = c(12, 12), permute_penalty = 12, break_penalty = 0.95,
  penalty_scaling = purrr::partial(linear_scaling, nx = nrow(df1), ny =
  nrow(df2)), ignore_cols = NULL, insert_col_prefix = "INSERT.",
  attach_costs_matrices = FALSE, scale_break_penalty = FALSE,
  as.list = FALSE, verbose = FALSE)
}
\arguments{
\item{df1, df2}{A pair of data frames.}

\item{mismatch}{Mismatch method. The default is \code{\link{diffness}}.}

\item{patch_generators}{A list of patch generator functions from which, for each pair of columns (one
each from \code{df1} & \code{df2}), candidate patches will be generated.}

\item{patch_penalties}{A numeric vector of patch penalties corresponding to the \code{patch_generators}
list. The lengths of these two arguments must be equal.}

\item{permute_penalty}{The penalty associated with a permutation patch. This penalty is scaled, using
the \code{penalty_scaling} argument, and multiplied by the number of columns
whose index is changed by the permutation.}

\item{break_penalty}{The penalty associated with a break patch. By default no scaling is applied
to the \code{break_penalty}. To change this use the \code{scale_break_penalty}
argument.}

\item{penalty_scaling}{A function to be used to scale the penalty associated with each patch.
Defaults to \code{\link{ks_scaling}}.}

\item{ignore_cols}{(Optional) An integer vector specifying corresponding columns in \code{df1}
and \code{df2} to be excluded from consideration. Defaults to \code{NULL},
meaning do not ignore any columns.}

\item{insert_col_prefix}{The prefix used to name inserted columns, if \code{df1} has fewer columns
than \code{df2}. Defaults to 'INSERT.'.}

\item{attach_costs_matrices}{A logical flag. If \code{TRUE} the square costs matrices, on which the final
column assignment is based, are attached to the return value as attributes
with the names \code{mismatch} and \code{penalty}. This option is
included to make the operation of the function more transparent (for
debugging, say). Defaults to \code{FALSE}.}

\item{scale_break_penalty}{A logical flag to turn on/off scaling of the break penalty. Defaults to
\code{FALSE}.}

\item{as.list}{A logical flag. If \code{TRUE} the return value is a list of patches.
Otherwise a composite patch object is returned.}

\item{verbose}{A logical flag.}
}
\value{
A composite patch object or, if \code{as.list} is \code{TRUE}, its
decomposition as a list of elementary patches.
}
\description{
Given two data frames and a collection of patch generator functions, with
associated (numeric) penalties, this function attempts to identify a
sequence of transformations to best explain the difference and returns the
result as a (composite) patch.
}
\details{
The steps in the algorithm are:
\itemize{
 \item For each column pair \eqn{(i, j)} in \eqn{df1 \times df2}, identify the
 candidate patch \eqn{p_{ij}} which minimises the quantity
 \deqn{\mbox{mismatch}(p_{ij}(df1)[[i]], df2[[j]]) + \mbox{penalty}(p_{ij})}
 among all patches generated by the given \code{patch_generators}. Also
 include the identity patch and break patch as possible candidates; the
 former incurs zero penalty, the latter zero mismatch.

 \item Construct a matrix of dimension
 \eqn{\mbox{ncol}(df1) \times \mbox{ncol}(df2)} containing the cost
 (i.e. mismatch + penalty) associated with each of the candidate patches.
 If \eqn{\mbox{ncol}(df1) = \mbox{ncol}(df2)}, include also the
 penalties associated with a permutation of the columns (equal to the scaled
 \code{permute_penalty} for all \eqn{i \neq j}, and zero otherwise).

 \item Apply the Hungarian algorithm to solve the problem of assigning
 columns in \code{df1} to those in \code{df2}, based on the costs matrix
 constructed in the preceding step.

 \item In case \eqn{\mbox{ncol}(df1) \neq \mbox{ncol}(df2)}:
 \itemize{
  \item Use the solution to the assignment problem to determine the indices
  at which columns are to be inserted or deleted, and construct the
  corresponding insert or delete patch object(s).
  \item Update the costs matrix, by inserting or removing rows, to reflect
  the insertions/deletions. New rows (corresponding to insertions) have ones
  in every position except for a zero on the main diagonal. The result is a
  square costs matrix.
  \item Add to the square costs matrix the penalties associated with a
  permutation of the columns (equal to the scaled \code{permute_penalty} for
  all \eqn{i \neq j}, and zero otherwise). Since the permutation penalties are
  added to the "squared" costs matrix, the permutation cost is zero when the
  column indices are equal \emph{after any insertions/deletions}.
  \item Solve the assignment problem based on the updated costs matrix (again
  using the Hungarian algorithm).
 }

 \item Use the solution to the assignment problem to identify:
 \itemize{
  \item which of the
 columnwise candidate patches (from the first step) are to be included in the
 result.
  \item what (if any) permutation of columns is required.
  }

 \item Construct the result by composing the columnwise, insert/delete and
 permutation patches \emph{in that order}.
}
}
\examples{
\dontrun{
ddiff(mtcars, mtcars[, 11:1])
}

}
