% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch.R
\name{patch}
\alias{patch}
\title{Patch S3 class constructor.}
\usage{
patch(params, predicates = list())
}
\arguments{
\item{params}{A parameters object which determines both the patch type and the specific
action of the \code{patch}.}

\item{predicates}{A optional named list of predicates. This should be ignored except when
using additional \code{patch} types (i.e. types which are not supported by
default). See the 'Details' section below.

Each predicate must enable the particular \code{patch} type to be determined
(by returning \code{TRUE} when called on a corresponding \code{params}
object and \code{FALSE} otherwise). Element names in the \code{predicates}
list must precisely match the corresponding \code{patch} type names.

The built-in predicates contained in the \code{datadiff:::type_predicates}
object will be added to this list (overwriting any existing predicates with
matching names). Note that, for any given \code{params} object, precisely
one predicate must evaluate to \code{TRUE} otherwise the \code{patch}
constructor will fail with an error.}
}
\description{
S3 class \code{patch} which extends the \code{function} class to represent a
generic transformation of a tabular dataset. The transformation is executed
by evaluating the \code{patch} (function) on a data frame. Any additional
arguments passed to the \code{patch} function are passed on to the
\code{is_compatible} and \code{return_value} methods (see the 'Details'
section below).

See the 'Details' section for a step-by-step guide explaining how to create
new patch types to enable dataset transformations which are not already
supported.
}
\details{
A \code{patch} is a closure with an object named \code{params} in its
enclosing environment, accessed via the \code{\link{patch_params}} function.
The form of the \code{params} object determines the type of the \code{patch}
(via a corresponding predicate), which in turn determines the form of the
transformation. The \code{\link{patch_type}} function returns the type as a
character string. The specific operation of a \code{patch} instance is
determined by the value(s) inside its \code{params} object according to the
rule encoded in the (generic) function \code{return_value}.

For example, if \code{params} is a non-empty vector of unique, negative
integers then the corresponding patch type is \code{delete.patch},
representing a transformation which deletes one or more columns from a data
frame. The (negative) integer values in the vector specify the indices of
the columns to be deleted.

Several \code{patch} types are supported by default (see
\code{\link{predicates}} for details of built-in types). The \code{patch}
class has also been designed to allow new types to be included with minimal
effort and to thereby support arbitrary transformations of (tabular)
datasets.

To add a new patch type:
\enumerate{
 \item Choose a name for the new type which does not conflict with any of
 the existing ones - see \code{names(datadiff:::type_predicates)}.

 \item Implement the generic methods \code{is_compatible} and
 \code{return_value} by writing new functions named
 \code{is_compatible.<new_type_name>} and
 \code{return_value.<new_type_name>}, respectively. It is recommended that
 this is done in a file whose name matches the name of the type.

 Simple examples, for the \code{delete.patch} type, are
 \code{\link{is_compatible.delete.patch}} and
 \code{\link{return_value.delete.patch}}.

 \item Construct a predicate to enable the new type to be inferred from the
 patch parameters object.

 Examples of such predicates may be found in the
 \code{datadiff:::type_predicates} list. The new predicate must not conflict
 with the existing ones in the sense that, for any given \code{params}
 object, at most one predicate may return \code{TRUE}.

 \item Construct a named list which contains the new predicate (constructed
 in step 3) with corresponding element name precisely matching the new type
 name (i.e. identical to the suffix \code{<new_type_name>} used when
 implementing the generic methods in step 2).

 The elements in the \code{datadiff:::type_predicates} list will be
 automatically added to this list. Note that, for any given (valid)
 \code{params} object, precisely one predicate must evaluate to \code{TRUE}
 otherwise the \code{patch} constructor will fail with an error.

 \item Construct \code{patch} objects of the new type by calling the usual
 constructor and passing both the \code{params} object and the list of
 predicates constructed in step 4.
}
}
\examples{

# Delete a column.
colnames(mtcars)
p1 <- patch(-2L)
colnames(p1(mtcars))

# Permute some columns.
p2 <- patch(c(2L, 5L, 7L))
colnames(p2(mtcars))

# Re-encode categorical data.
purrr::map_chr(mtcars, class)
p3 <- patch(encode_patch_params(c(8L, 9L), c("0" = FALSE, "1" = TRUE)))
purrr::map_chr(p3(mtcars), class)

# Rescale numerical data.
mean(mtcars[[1]]) # Average miles per gallon
p4 <- patch(scale_patch_params(1L, 0.425144))
mean(p4(mtcars)[[1]]) # Average km per litre

# Patches may be composed. The following are equivalent:
purrr::map_chr(p1(p2(p3(p4(mtcars)))), class)
purrr::map_chr(purrr::compose(p1, p2, p3, p4)(mtcars), class)
purrr::map_chr(Reduce(purrr::compose, list(p1, p2, p3, p4))(mtcars), class)

# Attempting to apply a patch to an incompatible data frame throws an error.
\dontrun{
p <- patch(-as.integer(ncol(mtcars) + 1))
p(mtcars)
}
}
\seealso{
\code{\link{predicates}} \code{\link{patch_type}}
\code{\link{patch_params}}
}
