#' Diff two data frames
#'
#' @description
#' Given two data frames and a collection of patch generator functions, with
#' associated (numeric) penalties, this function attempts to identify a
#' sequence of transformations to best explain the difference and returns the
#' result as a (composite) patch.
#'
#' @details
#' The steps in the algorithm are:
#' \itemize{
#'  \item For each column pair \eqn{(i, j)} in \eqn{df1 x df2}, identify the
#'  candidate patch \eqn{p_ij} which minimises the quantity
#'  \deqn{mismatch(p_ij(df1)[[i]], df2[[j]]) + penalty(p_ij)}
#'  among all patches generated by the given \code{patch_generators}. Also
#'  include the identity patch and break patch as possible candidates; the
#'  former incurs zero penalty, the latter zero mismatch.
#'
#'  \item Construct a matrix of dimension \eqn{ncol(df1) x ncol(df2)}
#'  containing the cost (i.e. mismatch + penalty) associated with each of the
#'  candidate patches. If \eqn{ncol(df1) == ncol(df2)}, include also the
#'  penalties associated with a permutation of the columns (equal to the scaled
#'  \code{permute_penalty} for all \eqn{i != j}, and zero otherwise).
#'
#'  \item Apply the Hungarian algorithm to solve the problem of assigning
#'  columns in \code{df1} to those in \code{df2}, based on the costs matrix
#'  constructed in the preceding step.
#'
#'  \item In case \eqn{ncol(df1) != ncol(df2)}:
#'  \itemize{
#'   \item Use the solution to the assignment problem to determine the indices
#'   at which columns are to be inserted or deleted, and construct the
#'   corresponding insert or delete patch object(s).
#'   \item Update the costs matrix, by inserting or removing rows, to reflect
#'   the insertions/deletions. New rows (corresponding to insertions) have ones
#'   in every position except for a zero on the main diagonal. The result is a
#'   square costs matrix.
#'   \item Add to the square costs matrix the penalties associated with a
#'   permutation of the columns (equal to the scaled \code{permute_penalty} for
#'   all \eqn{i != j}, and zero otherwise). Since the permutation penalties are
#'   added to the "squared" costs matrix, the permutation cost is zero when the
#'   column indices are equal \emph{after any insertions/deletions}.
#'   \item Solve the assignment problem based on the updated costs matrix (again
#'   using the Hungarian algorithm).
#'  }
#'
#'  \item Use the solution to the assignment problem to identify:
#'  \itemize{
#'   \item which of the
#'  columnwise candidate patches (from the first step) are to be included in the
#'  result.
#'   \item what (if any) permutation of columns is required.
#'   }
#'
#'  \item Construct the result by composing the columnwise, insert/delete and
#'  permutation patches \emph{in that order}.
#' }
#'
#' @param df1,df2
#' A pair of data frames.
#' @param mismatch
#' Mismatch method. The default is \code{\link{diffness}}.
#' @param patch_generators
#' A list of patch generator functions from which, for each pair of columns (one
#' each from \code{df1} & \code{df2}), candidate patches will be generated.
#' @param patch_penalties
#' A numeric vector of patch penalties corresponding to the \code{patch_generators}
#' list. The lengths of these two arguments must be equal.
#' @param permute_penalty
#' The penalty associated with a permutation patch. This penalty is scaled, using
#' the \code{penalty_scaling} argument, and multiplied by the number of columns
#' whose index is changed by the permutation.
#' @param break_penalty
#' The penalty associated with a break patch.
#' @param penalty_scaling
#' A function to be used to scale the penalty associated with each patch.
#' Defaults to \code{\link{ks_scaling}}.
#' @param insert_col_name
#' The column name used for inserted columns, if \code{df1} has fewer columns
#' than \code{df2}. Defaults to 'INSERT'.
#' @param as.list
#' A logical flag. If \code{TRUE} the return value is a list of patches.
#' Otherwise a composite patch object is returned.
#' @param verbose
#' A logical flag.
#'
#' @return A composite patch object or, if \code{as.list} is \code{TRUE}, its
#' decomposition as a list of elementary patches.
#'
#' @export
#'
ddiff <- function(df1, df2,
                  mismatch = diffness,
                  patch_generators = list(gen_patch_transform),
                  patch_penalties = 0.6,
                  permute_penalty = 0.1,
                  break_penalty = 0.95,
                  penalty_scaling = purrr::partial(ks_scaling, nx = nrow(df1),
                                                   ny = nrow(df2)),
                  insert_col_name = "NEW.COLUMN",
                  as.list = FALSE, verbose = FALSE) {

  stopifnot(is.data.frame(df1) && is.data.frame(df2))
  stopifnot(permute_penalty >= 0 && permute_penalty <= 1)
  stopifnot(all(patch_penalties >= 0) && all(patch_penalties <= 1))
  stopifnot(break_penalty >= 0)

  # Construct a nested list of candidate patches between column pairs.
  mismatch_attr <- "mismatch"; penalty_attr <- "penalty"
  cw_candidates <- columnwise_candidates(df1, df2 = df2,
                                         mismatch = mismatch,
                                         patch_generators = patch_generators,
                                         patch_penalties = patch_penalties,
                                         break_penalty = break_penalty,
                                         penalty_scaling = penalty_scaling,
                                         mismatch_attr = mismatch_attr,
                                         penalty_attr = penalty_attr,
                                         verbose = verbose)

  # Extract the costs matrix (from attributes attached to the candidates).
  extract_matrix <- function(attr_name) {
    matrix(purrr::map_dbl(unlist(cw_candidates), .f = function(p) {
      attr(p, attr_name)
    }), nrow = ncol(df1), ncol = ncol(df2), byrow = TRUE) }
  m_mismatch <- extract_matrix(mismatch_attr)
  m_penalty <- extract_matrix(penalty_attr)

  # Add the permutation penalties only if ncol(df1) == ncol(df2). Otherwise,
  # add those penalties later (when the penalties matrix has been made square).
  add_permute_penalty <- function(m) {
    m + penalty_scaling(permute_penalty) * (1 - diag(nrow(m))) }
  if (ncol(df1) == ncol(df2))
    m_penalty <- add_permute_penalty(m_penalty)

  # Solve the problem of assigning columns in df1 to those in df2 with minimum
  # cost. The solution has length max(ncol(df1), ncol(df2)).
  soln <- solve_pairwise_assignment(m_mismatch + m_penalty, verbose = verbose)

  # Handle the possibility that ncol(df2) != ncol(df1).
  column_is_unassigned <- soln > ncol(df2)
  column_is_not_assigned_to <- !(1:length(soln) %in% soln[1:ncol(df1)])

  # Construct an empty list to hold the result.
  patch_list <- list()

  # In case ncol(df1) < ncol(df2), identify the requisite insert patch(es).
  if (any(column_is_not_assigned_to)) {

    insert_col_data <- data.frame(rep(NA, nrow(df1)))
    colnames(insert_col_data) <- insert_col_name

    # Update each cost matrix (with a new row corresponding to each column in
    # df2 which is not assigned to) & construct a list of insert patches.
    update_matrix <- function(m, i) {
      ret <- rbind(m[0:(i - 1), ], (1 - diag(ncol(df2)))[i, ])
      if (i <= nrow(m))
        ret <- rbind(ret, m[i:nrow(m), ])
      ret
    }
    p_insert <- purrr::map(which(column_is_not_assigned_to), .f = function(i) {
      m_mismatch <<- update_matrix(m_mismatch, i)
      m_penalty <<- update_matrix(m_penalty, i)
      patch_insert(as.integer(i - 1), data = insert_col_data)
    })
    patch_list <- c(patch_list, p_insert)
  }
  # In case ncol(df1) > ncol(df2), identify the requisite delete patch(es).
  if (any(column_is_unassigned)) {

    # Update each cost matrix (by removing those rows corresponding to columns
    # in df1 which are unassigned) & construct a list of delete patches.
    update_matrix <- function(m, i) { m[-i, ] }
    p_delete <- purrr::map(sort(which(column_is_unassigned), decreasing = TRUE),
                           .f = function(i) {
                             m_mismatch <<- update_matrix(m_mismatch, i)
                             m_penalty <<- update_matrix(m_penalty, i)
                             patch_delete(as.integer(i))
                           })
    patch_list <- c(patch_list, p_delete)
  }

  # If necessary, solve the assignment problem under the updated costs matrices.
  # Include the permutation penalties (now that the penalties matrix is square).
  if (any(column_is_not_assigned_to) || any(column_is_unassigned)) {
    m_penalty <- add_permute_penalty(m_penalty)
    soln <- solve_pairwise_assignment(m_mismatch + m_penalty, verbose = verbose)
  }

  # Extract the columnwise patches corresponding to the solution. Note that the
  # columnwise patch objects contain column identifiers which refer to indices
  # in df1, so we *must* apply those patches *before* any insertions/deletions.
  assignedColumns <- (1:ncol(df1))[!(column_is_unassigned[1:ncol(df1)])]
  p_columnwise <- purrr::map(1:length(assignedColumns), .f = function(i) {
    cw_candidates[[assignedColumns[i]]][[soln[!column_is_not_assigned_to][i]]]
  })
  patch_list <- c(p_columnwise, patch_list)

  # Add the permutation patch (if non-trivial). Note that any permutation must
  # be applied *after* any insertions/deletions.
  perm <- order(soln)
  if (!identical(perm, 1:ncol(df2)))
    patch_list <- c(patch_list, patch_perm(perm))

  p <- simplify_patch(Reduce(compose_patch, rev(patch_list)))
  if (as.list)
    return(decompose_patch(p))
  p
}
